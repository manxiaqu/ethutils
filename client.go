package ethutils

import (
	"context"
	"errors"
	"math/big"
	"time"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/ethereum/go-ethereum/rpc"
	log "github.com/inconshreveable/log15"
)

// RPCClient implements methods by calling rpc client
type RPCClient struct {
	c *rpc.Client
}

// MustGetRPCClient returns a ethereum rpc client instance.
func MustGetRPCClient(url string) *RPCClient {
	c, err := rpc.DialContext(context.Background(), url)
	if err != nil {
		panic(err)
	}

	return &RPCClient{c}
}

// IsMining checks the miner is mining or not.
func (rc *RPCClient) IsMining() (bool, error) {
	var res bool
	err := rc.c.Call(&res, "eth_mining")

	return res, err
}

// StopMining stop miner mining process
func (rc *RPCClient) StopMining() (bool, error) {
	var r bool
	err := rc.c.Call(&r, "miner_stop")
	return r, err
}

// StartMining start miner mining process
func (rc *RPCClient) StartMining() (bool, error) {
	var r bool
	err := rc.c.Call(&r, "miner_start")
	return r, err
}

// MustGetClient panics if can't get client
func MustGetClient(url string) *ethclient.Client {
	client, err := ethclient.Dial(url)
	if err != nil {
		panic(err)
	}

	return client
}

// MustSetNonce sets nonce to ethereum account if nonce is nil.
func MustSetNonce(client *ethclient.Client, account *bind.TransactOpts) {
	nonce, err := client.NonceAt(context.Background(), account.From, nil)
	if err != nil {
		panic(err)
	}

	account.Nonce = new(big.Int).SetUint64(nonce)
}

// WaitForTx stuck until tx is included in a block.
// receipt of tx will be returned
func WaitForTx(client *ethclient.Client, hash common.Hash) (*types.Receipt, error) {
	for {
		select {
		case <-time.After(time.Minute * 2):
			return nil, errors.New("time out")
		default:
			receipt, _ := client.TransactionReceipt(context.Background(), hash)
			if receipt != nil {
				return receipt, nil
			}
			time.Sleep(1 * time.Second)
		}
	}
}

// DeployFunc deploys contracts when executing.
type DeployFunc func() (common.Address, *types.Transaction, interface{}, error)

// AutoDeploy deploys contract/ panic if error/logs info info.
// Transaction sender's nonce will add 1 automatically.
func AutoDeploy(optionName string, deployFunc DeployFunc, auth *bind.TransactOpts) (common.Address, *types.Transaction, interface{}) {
	addr, tx, inter, err := deployFunc()
	PanicIfErr(err)

	// Sender nonce add 1.
	auth.Nonce.Add(auth.Nonce, One)

	if optionName == "" {
		log.Info("deploy contract", "tx", tx.Hash().Hex(), "address", addr.Hex())
	} else {
		log.Info("deploy contract", "name", optionName, "tx", tx.Hash().Hex(), "address", addr.Hex())
	}

	return addr, tx, inter
}

// TransactFunc is a func to send tx to contract. Panic if errors.
// Transaction sender's nonce will add 1 automatically.
type TransactFunc func() (*types.Transaction, error)

// AutoSendTx send tx to contract using contract object generated by abigen. Panic if errors.
// Transaction sender's nonce will add 1 automatically.
func AutoSendTx(optionName string, transactFunc TransactFunc, auth *bind.TransactOpts) *types.Transaction {
	tx, err := transactFunc()
	if err != nil {
		panic(err)
	}

	// Sender nonce add 1.
	auth.Nonce.Add(auth.Nonce, One)
	if optionName == "" {
		log.Info("send tx to contract", "tx", tx.Hash().Hex())
	} else {
		log.Info("send tx to contract", "txName", optionName, "tx", tx.Hash().Hex())
	}

	return tx
}
